import re
from itertools import compress

import numpy as np
import pandas as pd
from typing import Optional
from sentence_transformers import SentenceTransformer

from similarity.DataFrameMetadata import DataFrameMetadata, CategoricalMetadata
from similarity.Types import Types, get_type


class DataFrameMetadataCreator:
    """
    This class gets dataframe and creates metadata.
    Specific metadata will be created after calling specific function.
    User will get created metadata by calling get_metadata()
    """

    ## generated by computer/person
    ## distribution of numerical data
    ## most common triplets, ... for text data
    ##
    def __init__(self, dataframe: pd.DataFrame):
        """
        Constructor of DataFrameMetadataCreator
        :param dataframe: DataFrame from which we will create metadata

        size of metadata will be set to number of DataFrames rows
        column_names_clean will be set to column names with only letters and numbers
        column_name_embeddings will be created by using vector embedding model
        type_column - each type will have list of names of columns with this specific type
        column_categorical - list of booleans, for each column list will contain
                            True for categorical data and False for not categorical
        column_incomplete - list of booleans, for each column list will contain
                            True for incomplete data and False otherwise
        """
        self.dataframe = dataframe
        self.metadata = DataFrameMetadata()
        self.metadata.size = dataframe.shape[0]
        self.metadata.column_names = list(dataframe.columns)
        self.metadata.column_names_clean = [re.sub("[^(0-9 | a-z).]", " ", i.lower()) for i in
                                            self.metadata.column_names]
        column_name_embeddings = self.__get_model().encode(self.metadata.column_names_clean)
        for i, name in zip(column_name_embeddings, self.metadata.column_names):
            self.metadata.column_name_embeddings[name] = i
        for i in dataframe.columns:
            self.metadata.type_column[get_type(dataframe[i])].add(i)

        self.metadata.column_categorical = [((i / (self.metadata.size * 0.01) < 1) or i < 50) for i in
                                            dataframe.nunique()]  # less than 10 %
        self.metadata.column_incomplete = [i < self.metadata.size * 0.7 for i in
                                           dataframe.count()]  # more than 30 % missing
        self.__compute_categorical_info()

        self.model: Optional[SentenceTransformer] = None

    def __get_model(self) -> SentenceTransformer:
        """
        :return: embedding model if exists or creates new one
        """
        if not self.model:
            self.model = SentenceTransformer('bert-base-nli-mean-tokens')
        return self.model

    def __compute_categorical_info(self) -> None:
        """
        Method creates CategoricalMetadata

        """
        categorical_names = list(compress(self.metadata.column_names, self.metadata.column_categorical))
        for name in categorical_names:
            # clean_categories = self.dataframe[name].notna().unique()
            # categories_embeddings = list()
            # for category in clean_categories:
            #     get_world_embedding(category)
            if name in self.metadata.type_column[Types.BOOL]:
                continue
            self.metadata.categorical_metadata[name] = CategoricalMetadata(count=self.dataframe[name].nunique(),
                                                                           categories=set(
                                                                               self.dataframe[name].unique()),
                                                                           categories_with_count=self.dataframe[
                                                                               name].value_counts(),
                                                                           category_embedding=self.__get_model().encode(
                                                                               list(map(str, self.dataframe[
                                                                                   name].unique()))))
            # categories_embeddings=categories_embeddings)

    def set_model(self, model: SentenceTransformer) -> 'DataFrameMetadataCreator':
        """
        Sets model
        :param model: to be set
        :return: self DataFrameMetadataCreator
        """
        self.model = model
        return self

    def compute_correlation(self, strong_correlation: float) -> 'DataFrameMetadataCreator':
        """
        Compute correlation for numerical columns and saves it to correlated_columns as tuple of correlation number and name of column
        :param strong_correlation: threshold for deciding if two columns are correlated
        :return: self DataFrameMetadataCreator
        """
        correlation_numerical = self.get_numerical_columns().corr()
        res = [(i, j) for i, j in zip(*np.where(np.abs(correlation_numerical.values) > strong_correlation))
               if i != j]  ## get pairs from matrics with bigger value then strong_correlation
        for r in res:
            self.metadata.correlated_columns.add(
                tuple(sorted((correlation_numerical.columns[r[0]],
                              correlation_numerical.iloc[r[1]].name))))  ## get names of rows and columns
        return self

    def create_column_embeddings(self, types=None) -> 'DataFrameMetadataCreator':
        """
        Creates embeddings for Types.STRING, Types.TEXT, Types.UNDEFINED or another types according to types parameter

        :param types: optional parameter for set desirable types
        :return: self DataFrameMetadataCreator
        """
        if types is None:
            types = [Types.STRING, Types.TEXT, Types.UNDEFINED]
        sentences = []
        names = []
        for i in types:
            for column in self.metadata.type_column[i]:
                sentences.append(str(self.dataframe[column].tolist())
                                 .replace("\'", "")
                                 .replace("]", "")
                                 .replace("[", ""))  # column to string
                names.append(column)
        column_embeddings = self.__get_model().encode(sentences)
        for i, name in zip(column_embeddings, names):
            self.metadata.column_embeddings[name] = i
        return self

    def get_column_by_type(self, *types):
        """
        :param types: of columns
        :return: dataframe with columns with specific types
        """
        return self.dataframe[self.metadata.get_column_names_by_type(types)]

    def get_numerical_columns(self):
        """
        :return: dataframe with only numerical columns
        """
        return self.dataframe[self.metadata.get_numerical_columns_names()]

    def get_metadata(self) -> DataFrameMetadata:
        """
        :return: created metadata
        """
        return self.metadata
