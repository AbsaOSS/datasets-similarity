"""
type_metadata_creator is a class that creates metadata for given Table.
"""

from __future__ import annotations

import math
import re
from typing import Optional

import numpy as np
import pandas as pd

from sentence_transformers import SentenceTransformer

from column2vec.src.column2vec import column2vec_as_sentence
from logging_ import logger
from similarity_framework.src.impl.types_functions import series_to_numeric, get_data_kind, get_advanced_type, get_advanced_structural_type, get_basic_type
from similarity_framework.src.models.settings import AnalysisSettings
from similarity_framework.src.models.metadata import (
    CategoricalMetadata,
    KindMetadata,
    NumericalMetadata,
    NonnumericalMetadata,
    IDMetadata,
    BoolMetadata,
    ConstantMetadata,
)
from similarity_framework.src.models.types_ import (
    DataKind,
    Type,
    NUMERICAL,
    NONNUMERICAL,
    UNDEFINED,
    WORD,
    ALL,
    MULTIPLE_VALUES,
    PHRASE,
    ARTICLE,
    ALPHANUMERIC,
    ALPHABETIC,
)

from similarity_framework.src.interfaces.metadata.metadata_creator import MetadataCreator


class TypeMetadataCreator(MetadataCreator):
    """
    This class gets dataframe and creates metadata.
    Specific metadata will be created after calling specific function.
    User will get created metadata by calling get_metadata()
    """

    @staticmethod
    def from_settings(settings: AnalysisSettings) -> "MetadataCreator":
        metadata_creator: TypeMetadataCreator = TypeMetadataCreator()
        if settings.correlation:
            metadata_creator.compute_correlation()
        if settings.incomplete_columns:
            metadata_creator.compute_incomplete_column()
        if settings.kinds:
            metadata_creator.compute_column_kind()
        if settings.type_basic:
            metadata_creator.compute_basic_types()
        if settings.type_advanced:
            metadata_creator.compute_advanced_types()
        if settings.type_structural:
            metadata_creator.compute_advanced_structural_types()
        if settings.column_name_embeddings:
            metadata_creator.compute_column_names_embeddings()
        if settings.column_embeddings:
            if not any([settings.type_basic, settings.type_advanced, settings.type_structural]):
                logger.warning("Column embeddings need to compute column types first, " "since none were provided falling back to: compute_basic_types")
                metadata_creator.compute_basic_types()
            metadata_creator.compute_column_embeddings()
        return metadata_creator

    # generated by computer/person
    # distribution of numerical data
    # most common triplets, ... for text data
    def __init__(self):
        """
        Constructor of TypeMetadataCreator
        :param dataframe: DataFrame from which we will create metadata

        size of metadata will be set to number of DataFrames rows
        column_names_clean will be set to column names with only letters and numbers, in lower case
        column_name_embeddings will be created by using vector embedding model
        column_type - each type will have list of names of columns with this specific type
        column_categorical - list of booleans, for each column list will contain
                            True for categorical data and False for not categorical
        column_incomplete - list of booleans, for each column list will contain
                            True for incomplete data and False otherwise
        """
        super().__init__()
        self.model: Optional[SentenceTransformer] = SentenceTransformer(
            "sentence-transformers/all-mpnet-base-v2", tokenizer_kwargs={"clean_up_tokenization_spaces": True}
        )

    def __normalize(self, num1: int, num2: int) -> tuple[int, int]:
        """
        Normalize fraction, ratio between two numbers
        :param num1:
        :param num2:
        :return: tuple of two numbers
        """
        gcd = math.gcd(num1, num2)
        if num1 > num2:
            return int(num2 / gcd), int(num1 / gcd)
        return int(num1 / gcd), int(num2 / gcd)

    def __compute_kind_metadata(self, kind: DataKind, column: pd.Series) -> KindMetadata | None:
        if kind == DataKind.BOOL:
            count = column.value_counts()
            null_values = True if len(column) != count.iloc[0] + count.iloc[1] else False
            return BoolMetadata(
                tuple(
                    [
                        count.keys()[0],
                        count.keys()[1],
                    ]
                ),
                self.__normalize(count.iloc[0], count.iloc[1]),
                null_values,
                self.get_model(),
            )
        if kind == DataKind.ID:
            null_values = True if column.nunique() != len(column) else False
            longest = column[column.apply(str).map(len).argmax()]
            shortest = column[column.apply(str).map(len).argmin()]
            return IDMetadata(longest, shortest, null_values, column.apply(str).map(len).max() / column.size, self.get_model())
        if kind == DataKind.CONSTANT:
            count = column.value_counts().iloc[0]
            length = len(column)
            if length != count:
                return ConstantMetadata(tuple([column.dropna().unique()[0]]), self.__normalize(count, length - count), True, self.get_model())
            return ConstantMetadata(tuple([column.dropna().unique()[0]]), None, False, self.get_model())
        return None

    def __compute_type_metadata(self, type_: type[Type], column: pd.Series, name: str) -> None:
        """
        Compute metadata for numerical and nonnumerical columns
        column.str.len().nunique() == 1 returns len for each element in series, then we count number of uniq values
        -> how many elements have the same length

        :param type_: of column
        :param column: the specific column
        :param name: name of the column
        :return: None
        """
        if issubclass(type_, NUMERICAL):
            column = series_to_numeric(column)
            self.metadata.numerical_metadata[name] = NumericalMetadata(
                column.min(),
                column.max(),
                (column.astype(str).str.len().nunique() == 1),
            )
        elif issubclass(type_, NONNUMERICAL):
            self.metadata.nonnumerical_metadata[name] = NonnumericalMetadata(
                column[column.astype(str).str.len().idxmax()],  # longest string
                column[column.astype(str).str.len().idxmin()],  # shortest string
                int(column.astype(str).str.len().mean()),
            )

    def get_model(self) -> SentenceTransformer:
        """
        :return: embedding model if exists or creates new one
        """
        if not self.model:
            self.model = SentenceTransformer("sentence-transformers/all-mpnet-base-v2", tokenizer_kwargs={"clean_up_tokenization_spaces": True})
        return self.model

    # Setting Creator

    def set_model(self, model: SentenceTransformer) -> "TypeMetadataCreator":
        """
        Sets model
        :param model: to be set
        :return: self TypeMetadataCreator
        """
        self.model = model
        return self

    @MetadataCreator.buildermethod
    def compute_column_names_embeddings(
        self,
    ) -> "TypeMetadataCreator":
        """
        Computes embeddings for all column names

        :return: self
        """
        column_name_embeddings = self.get_model().encode(list(self.metadata.column_names_clean.values()))
        for i, name in zip(
            column_name_embeddings,
            self.metadata.column_names,
        ):
            self.metadata.column_name_embeddings[name] = i
        return self

    @MetadataCreator.buildermethod
    def compute_column_kind(
        self,
    ) -> "TypeMetadataCreator":
        """
        This will compute columns kinds (id, bool, undefined, constant, categorical) and kind metadata
        and categorical metadata

        :return: self
        """
        for i in self.dataframe.columns:
            kind = get_data_kind(self.dataframe[i])
            self.metadata.column_kind[kind].add(i)
            self.metadata.kind_metadata[i] = self.__compute_kind_metadata(kind, self.dataframe[i])
            if kind == DataKind.CATEGORICAL:
                self.metadata.categorical_metadata[i] = CategoricalMetadata(
                    count=self.dataframe[i].nunique(),
                    categories=list(self.dataframe[i].unique()),
                    categories_with_count=self.dataframe[i].value_counts(),
                    category_embedding=self.get_model().encode(
                        list(
                            map(
                                str,
                                self.dataframe[i].unique(),
                            )
                        )
                    ),
                )
        return self

    @MetadataCreator.buildermethod
    def compute_basic_types(
        self,
    ) -> "TypeMetadataCreator":
        """
        Computes types of columns only numerical, date, not numerical and undefined
        computes metadata

        :return: self
        """
        for i in self.dataframe.columns:
            type_ = get_basic_type(self.dataframe[i])
            self.metadata.column_type[type_].add(i)
            self.__compute_type_metadata(type_, self.dataframe[i], i)
        return self

    @MetadataCreator.buildermethod
    def compute_advanced_types(
        self,
    ) -> "TypeMetadataCreator":
        """
        Computes types of columns. Indicates types int, float, date, text
        computes metadata

        :return: self
        """
        for i in self.dataframe.columns:
            type_ = get_advanced_type(self.dataframe[i])
            self.metadata.column_type[type_].add(i)
            self.__compute_type_metadata(type_, self.dataframe[i], i)
        return self

    @MetadataCreator.buildermethod
    def compute_advanced_structural_types(
        self,
    ) -> "TypeMetadataCreator":
        """
        Compute types of columns. Indicates type of column int, float - human, computer,
         date, text - word, sentence, phrase article, multiple computes metadata

        :return: self
        """
        for i in self.dataframe.columns:
            type_ = get_advanced_structural_type(self.dataframe[i])
            self.metadata.column_type[type_].add(i)
            self.__compute_type_metadata(type_, self.dataframe[i], i)
        return self

    @MetadataCreator.buildermethod
    def compute_numerical_correlation(self, strong_correlation: float) -> "TypeMetadataCreator":
        """
        Compute correlation for numerical columns and saves it to correlated_columns
        as tuple of correlation number and name of column

        :param strong_correlation: threshold for deciding if two columns are correlated
        :return: self TypeMetadataCreator
        """
        correlation_numerical = self.get_numerical_columns().corr()
        res = [
            (i, j) for i, j in zip(*np.where(np.abs(correlation_numerical.values) > strong_correlation)) if i != j
        ]  # get pairs from matrics with bigger value then strong_correlation
        for r in res:
            self.metadata.correlated_columns.add(
                tuple(sorted((correlation_numerical.columns[r[0]], correlation_numerical.iloc[r[1]].name)))
            )  # get names of rows and columns
        return self

    @MetadataCreator.buildermethod
    def compute_correlation(self) -> "TypeMetadataCreator":
        self.metadata.correlated_columns = self.dataframe.corr()
        return self

    @MetadataCreator.buildermethod
    def compute_column_embeddings(self, types: list = None) -> "TypeMetadataCreator":
        """
        Creates embeddings for Types.STRING, Types.TEXT, Types.UNDEFINED or another types according to types parameter

        :param types: optional parameter for set desirable types
        :return: self TypeMetadataCreator
        """
        if not self.metadata.column_type:
            raise RuntimeError(
                "Column types need to be computed before this method is called, "
                "use compute_basic_types, compute_advanced_types or compute_advanced_structural_types"
            )
        if types is None:
            types = [NONNUMERICAL, UNDEFINED, WORD, ALL, MULTIPLE_VALUES, PHRASE, ARTICLE, ALPHANUMERIC, ALPHABETIC]
        for i in types:
            for column in self.metadata.column_type[i]:
                self.metadata.column_embeddings[column] = column2vec_as_sentence(
                    self.dataframe[column],
                    self.get_model(),
                    column,
                )
        return self

    @MetadataCreator.buildermethod
    def compute_incomplete_column(self) -> "TypeMetadataCreator":
        """
        Compute incomplete columns and save it to metadata
        :return: self TypeMetadataCreator
        """

        # more than 30 % missing
        self.metadata.column_incomplete = {
            name: i < self.metadata.size * 0.7
            for i, name in zip(
                self.dataframe.count(),
                list(self.dataframe.columns),
            )
        }
        return self

    # Getters
    def get_column_by_type(self, *types: type[Type]) -> pd.DataFrame:
        """
        :param types: of columns
        :return: dataframe with columns with specific types
        """
        return self.dataframe[self.metadata.get_column_names_by_type(*types)]

    def get_column_by_kind(self, *kinds: DataKind) -> pd.DataFrame:
        """
        :param kinds: of columns
        :return: dataframe with columns with specific kind
        """
        return self.dataframe[self.metadata.get_column_names_by_kind(*kinds)]

    def get_numerical_columns(self):
        """
        :return: dataframe with only numerical columns
        """
        return self.dataframe[self.metadata.get_numerical_columns_names()]

    def _get_metadata_impl(self):
        """
        :return: created metadata
        """
        self.metadata.column_names = list(self.dataframe.columns)
        self.metadata.column_names_clean = {i: re.sub("[^(0-9 |a-z).]", " ", i.lower()) for i in self.metadata.column_names}
        self.metadata.size = self.dataframe.shape[0]
